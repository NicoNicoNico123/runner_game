<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Glide: Vapor City</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Vibur&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #120b29;
            --neon-pink: #ff2a6d;
            --neon-blue: #05d9e8;
            --neon-purple: #d300c5;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: white;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* Prevent zoom/scroll on mobile */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 960px;
            aspect-ratio: 16/9;
            box-shadow: 0 0 50px rgba(5, 217, 232, 0.2);
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* CRT Scanline Overlay */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        .scanlines::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #start-screen, #game-over-screen, #level-complete-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            backdrop-filter: blur(5px);
            text-align: center;
        }

        h1 {
            font-family: 'Vibur', cursive;
            font-size: 4rem;
            color: #fff;
            text-shadow: 0 0 10px #ff2a6d, 0 0 20px #ff2a6d, 0 0 40px #ff2a6d;
            margin-bottom: 0.5rem;
            letter-spacing: 2px;
        }

        h2 {
            color: var(--neon-blue);
            margin-bottom: 20px;
            font-size: 1.2rem;
            line-height: 1.5;
        }

        p {
            font-size: 0.8rem;
            line-height: 1.6;
            color: #ccc;
            max-width: 600px;
        }

        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }

        .btn {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 15px 30px;
            font-family: 'Press Start 2P', monospace;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 20px;
            transition: all 0.2s;
            pointer-events: auto;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .btn:hover {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px var(--neon-blue);
        }

        .hidden { display: none !important; }

        #hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .progress-bar {
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-purple), var(--neon-pink));
            width: 0%;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <div class="scanlines"></div>

    <!-- UI Overlay -->
    <div class="ui-layer">
        <div id="hud" class="hidden">
            <div id="city-name" style="color: var(--neon-blue); text-shadow: 2px 2px #d300c5;">TOKYO</div>
            <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>NEON GLIDE</h1>
        <h2>VAPOR CITY RUNNER</h2>
        <p>TAP or SPACE to Jump.</p>
        <p>Avoid solid traps and gaps.</p>
        <p>Collect the <span style="color:yellow">â˜…</span> for INCREDIBLE MODE.</p>
        <button class="btn" id="start-btn">INSERT COIN</button>
    </div>

    <!-- Level Complete Screen -->
    <div id="level-complete-screen" class="hidden">
        <h1 style="font-size: 3rem; color: #05d9e8; text-shadow: 0 0 20px #05d9e8;">CITY CLEARED</h1>
        <h2 id="next-city-name">NEXT: TOKYO</h2>
        <button class="btn" id="next-level-btn">TRAVEL</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <h1 style="font-size: 3rem; color: red; text-shadow: 0 0 20px red;">SYSTEM CRASH</h1>
        <p class="blink">CONNECTION LOST</p>
        <button class="btn" id="retry-btn">REBOOT</button>
    </div>
</div>

<script>
/**
 * ENGINE & CONSTANTS
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base
const GAME_WIDTH = 960;
const GAME_HEIGHT = 540;

// Input State
let keys = { space: false };
let inputActive = false;

// Game State
const STATE = {
    START: 0,
    PLAYING: 1,
    LEVEL_COMPLETE: 2,
    GAME_OVER: 3,
    VICTORY: 4
};

let currentState = STATE.START;
let frameCount = 0;
let lastTime = 0;

// Levels Config
const LEVELS = [
    {
        name: "HONG KONG",
        sub: "NEON HARBOR",
        theme: "pink",
        speed: 6.0,
        gravity: 0.6,
        jumpForce: -13,
        bgColors: ['#2b003b', '#48005f', '#1a0b2e'], // Deep purples
        traps: ["bamboo", "ac_unit"],
        layout: "easy"
    },
    {
        name: "TOKYO",
        sub: "CYBER SHIBUYA",
        theme: "blue",
        speed: 8,
        gravity: 0.65,
        jumpForce: -13.5,
        bgColors: ['#001e42', '#004269', '#000814'], // Deep blues
        traps: ["vending", "billboard"],
        layout: "medium"
    },
    {
        name: "EUROPE",
        sub: "SYNTH GOTHIC",
        theme: "gold",
        speed: 9.5,
        gravity: 0.7,
        jumpForce: -14,
        bgColors: ['#2e0b0b', '#5f1212', '#140000'], // Deep reds
        traps: ["fence", "statue"],
        layout: "hard"
    }
];

let currentLevelIndex = 0;

/**
 * GAME OBJECTS
 */

class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }
    update(playerX) {
        // Keep player on left 1/4 of screen
        this.x = playerX - 150;
        if(this.x < 0) this.x = 0;
    }
}

class Player {
    constructor() {
        this.width = 30;
        this.height = 48;
        this.x = 100;
        this.y = 300;
        this.vx = 0;
        this.vy = 0;
        this.isGrounded = false;
        this.color = '#00ffff'; // Blue hair base
        this.trail = [];
        
        // Incredible Mode
        this.isIncredible = false;
        this.incredibleTimer = 0;
        this.animFrame = 0;
    }

    reset(speed) {
        this.x = 100;
        this.y = 300;
        this.vx = speed;
        this.vy = 0;
        this.isGrounded = false;
        this.isIncredible = false;
        this.trail = [];
    }

    jump(force) {
        if (this.isGrounded) {
            this.vy = force;
            this.isGrounded = false;
            // Spawn jump dust
            createParticles(this.x + this.width/2, this.y + this.height, 10, '#fff');
        }
    }

    update(dt, gravity, floorY, platforms) {
        // Incredible Timer
        if (this.isIncredible) {
            this.incredibleTimer -= dt;
            if (this.incredibleTimer <= 0) {
                this.isIncredible = false;
            }
        }

        // Physics
        this.vy += gravity;
        this.y += this.vy;
        this.x += this.vx;

        this.isGrounded = false;

        // Collision: Platforms
        // Simple AABB for top collision only (landing)
        // We only collide if we are falling (vy > 0) and were previously above the platform
        const bottom = this.y + this.height;
        const prevBottom = (this.y - this.vy) + this.height;

        // Floor / Pit check
        // Check map specific platforms first
        let onPlatform = false;
        
        for (let p of platforms) {
            if (this.x + this.width > p.x && this.x < p.x + p.w) {
                // Horizontal overlap
                // Check vertical landing
                if (bottom >= p.y && prevBottom <= p.y + 10 && this.vy >= 0) {
                    this.y = p.y - this.height;
                    this.vy = 0;
                    this.isGrounded = true;
                    onPlatform = true;
                }
            }
        }

        // Death by pit
        if (this.y > GAME_HEIGHT + 100) {
            die();
        }

        // Trail effect
        if (frameCount % 3 === 0) {
            this.trail.push({x: this.x, y: this.y, alpha: 0.8});
            if (this.trail.length > 8) this.trail.shift();
        }

        this.animFrame++;
    }

    draw(ctx, camX) {
        // Draw Trail
        this.trail.forEach(t => {
            t.alpha -= 0.05;
            if (t.alpha < 0) t.alpha = 0;
            ctx.fillStyle = this.isIncredible 
                ? `rgba(255, 255, 0, ${t.alpha})` 
                : `rgba(0, 255, 255, ${t.alpha * 0.5})`;
            ctx.fillRect(t.x - camX, t.y, this.width, this.height);
        });

        const drawX = this.x - camX;
        const drawY = this.y;

        // Visual Glitch if Incredible
        let offsetX = 0;
        if (this.isIncredible) {
            offsetX = (Math.random() - 0.5) * 4;
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'yellow';
        } else {
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'cyan';
        }

        // Pixel Art Construction (The Blue-Haired Girl)
        ctx.save();
        ctx.translate(drawX + offsetX, drawY);

        // Body color
        const skin = '#ffccaa';
        const hair = this.isIncredible ? '#ffffaa' : '#00ffff';
        const clothes = '#ff2a6d';

        // 1. Legs (Animated)
        const runCycle = Math.floor(this.animFrame / 5) % 4;
        const legOffset = this.isGrounded ? (runCycle === 0 || runCycle === 2 ? 0 : 4) : -4;
        
        ctx.fillStyle = '#111'; // Tights
        if (this.isGrounded) {
             // Run animation
             if (runCycle === 0) { ctx.fillRect(5, 30, 8, 18); ctx.fillRect(17, 30, 8, 18); }
             else if (runCycle === 1) { ctx.fillRect(5, 28, 8, 15); ctx.fillRect(17, 32, 8, 16); }
             else if (runCycle === 2) { ctx.fillRect(5, 30, 8, 18); ctx.fillRect(17, 30, 8, 18); }
             else { ctx.fillRect(5, 32, 8, 16); ctx.fillRect(17, 28, 8, 15); }
        } else {
            // Jump pose
            ctx.fillRect(4, 28, 8, 14); // Back leg tucked
            ctx.fillRect(18, 32, 8, 16); // Front leg extended
        }

        // 2. Torso
        ctx.fillStyle = clothes;
        ctx.fillRect(5, 16, 20, 16);
        
        // 3. Head
        ctx.fillStyle = skin;
        ctx.fillRect(6, 0, 18, 16);

        // 4. Hair (Big blue vaporwave hair)
        ctx.fillStyle = hair;
        ctx.fillRect(4, -4, 22, 8); // Top
        ctx.fillRect(2, 0, 6, 18); // Left side
        ctx.fillRect(24, 0, 6, 18); // Right side
        // Ponytail trail
        if (this.vy > 0) ctx.fillRect(8, -8, 8, 6); // Up when falling
        else ctx.fillRect(8, -2, 8, 6); 

        // 5. Eye (Side profile ish)
        ctx.fillStyle = '#000';
        ctx.fillRect(20, 6, 2, 4);

        ctx.restore();
        ctx.shadowBlur = 0;
    }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = 1.0;
        this.size = Math.random() * 4 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.03;
        this.size *= 0.95;
    }
    draw(ctx, camX) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// Global systems
let particles = [];
function createParticles(x, y, count, color) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, 8));
    }
}

/**
 * LEVEL GENERATION
 */

// Map symbols:
// . or _ = Ground
// space  = Gap
// x      = Small Trap (Jump over)
// X      = Tall Trap (Must jump early/high)
// * = Incredible Powerup
// G      = Goal

const MAP_PATTERNS = {
    easy: [
        "................................",
        "......x............x............",
        "................................",
        "..........x.....................",
        ".....x...........x..............",
        "................................",
        "...........x..............x.....",
        "................................",
        ".......x.........x..............",
        "......................*.........",
        "....x...........x.......x......."
    ],
    medium: [
        "................................",
        ".......x..........x.............",
        "....x.......X...................",
        "..........x.....................",
        "...................x.....x......",
        "...............x................",
        "....X.....x...........x.........",
        "..........x........X.....X......",
        ".......................*........",
        "..x...x.........x...............",
        "................x...............",
        ".........................G......"
    ],
    hard: [
        "................................",
        ".....X.........x................",
        "...x......X.....................",
        ".........x........x.............",
        ".........x........X.....X.......",
        "............x...................",
        "...X.....x......................",
        "..........X.......X......x......",
        ".......................*........",
        "..X.........x.....x.............",
        "................x...............",
        "......X...X...X................."
    ]
};

function generateLevel(levelConfig) {
    const platforms = [];
    const traps = [];
    const powerups = [];
    let goalX = 0;

    // Base generation parameters
    const tileSize = 40;
    const groundY = GAME_HEIGHT - 60;
    
    // Construct string map
    let mapStr = "................"; // Safe start
    
    // Repeat patterns to make level long enough (~30 seconds)
    // 30s * 60fps * 8px/f = 14400px. Tile is 40px. Approx 360 tiles.
    const pattern = MAP_PATTERNS[levelConfig.layout];
    const repeats = 15; // Rough length
    
    for(let i=0; i<repeats; i++) {
        // Pick a random line from the pattern set or iterate? 
        // Let's iterate to give structure
        mapStr += pattern[i % pattern.length];
    }
    
    // Add finish line
    mapStr += "..........GGGG..........";

    // Parse Map
    for (let col = 0; col < mapStr.length; col++) {
        const char = mapStr[col];
        const x = col * tileSize;

        if (char === '.' || char === 'x' || char === 'X' || char === '*' || char === 'G') {
            // Ground
            platforms.push({ x: x, y: groundY, w: tileSize + 1, h: 60, type: 'ground' });
        }
        
        // Mid Platform logic removed

        if (char === 'x') {
            // Small Trap
            traps.push({ x: x + 10, y: groundY - 30, w: 20, h: 30, type: 'small' });
        }

        if (char === 'X') {
            // Tall Trap
            traps.push({ x: x + 5, y: groundY - 70, w: 30, h: 70, type: 'tall' });
        }

        if (char === '*') {
            powerups.push({ x: x + 10, y: groundY - 100, w: 20, h: 20, active: true });
        }

        if (char === 'G') {
            if (goalX === 0) goalX = x; // Mark start of goal
        }
    }

    return { platforms, traps, powerups, goalX, length: mapStr.length * tileSize };
}

let levelData = null;

/**
 * LOGIC
 */

const player = new Player();
const camera = new Camera();

function initLevel() {
    const config = LEVELS[currentLevelIndex];
    
    // Update UI
    document.getElementById('city-name').innerText = `${config.name} - ${config.sub}`;
    document.documentElement.style.setProperty('--neon-primary', config.theme === 'pink' ? '#ff2a6d' : (config.theme === 'blue' ? '#05d9e8' : '#ffd700'));

    // Generate Level
    levelData = generateLevel(config);
    
    // Reset Player
    player.reset(config.speed);
    
    camera.x = 0;
    particles = [];
}

function handleInput() {
    if (currentState === STATE.PLAYING) {
        player.jump(LEVELS[currentLevelIndex].jumpForce);
    }
}

function die() {
    createParticles(player.x, player.y, 30, '#fff');
    createParticles(player.x, player.y, 30, '#f0f');
    currentState = STATE.GAME_OVER;
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('hud').classList.add('hidden');
}

function levelComplete() {
    currentState = STATE.LEVEL_COMPLETE;
    const nextIdx = currentLevelIndex + 1;
    
    if (nextIdx >= LEVELS.length) {
        // Victory
        document.querySelector('#level-complete-screen h1').innerText = "VAPORWAVE MASTER";
        document.querySelector('#level-complete-screen h2').innerText = "ALL CITIES CONQUERED";
        document.getElementById('next-level-btn').innerText = "RESTART SIMULATION";
        document.getElementById('next-level-btn').onclick = () => location.reload();
    } else {
        document.getElementById('next-city-name').innerText = `NEXT: ${LEVELS[nextIdx].name}`;
    }
    
    document.getElementById('level-complete-screen').classList.remove('hidden');
    document.getElementById('hud').classList.add('hidden');
}

function update(dt) {
    if (currentState !== STATE.PLAYING) return;

    const config = LEVELS[currentLevelIndex];

    player.update(dt, config.gravity, GAME_HEIGHT - 60, levelData.platforms);
    camera.update(player.x);

    // Trap Collisions
    const px = player.x + 5;
    const py = player.y + 5;
    const pw = player.width - 10;
    const ph = player.height - 10;

    for (let i = levelData.traps.length - 1; i >= 0; i--) {
        const t = levelData.traps[i];
        if (t.destroyed) continue;

        if (px < t.x + t.w && px + pw > t.x && py < t.y + t.h && py + ph > t.y) {
            if (player.isIncredible) {
                // Destroy trap
                t.destroyed = true;
                createParticles(t.x + t.w/2, t.y + t.h/2, 15, '#ffff00');
            } else {
                die();
            }
        }
    }

    // Powerup Collisions
    for (let p of levelData.powerups) {
        if (p.active && px < p.x + p.w && px + pw > p.x && py < p.y + p.h && py + ph > p.y) {
            p.active = false;
            player.isIncredible = true;
            player.incredibleTimer = 300; // 5 seconds @ 60fps (roughly) or use DT
            player.incredibleTimer = 5.0; // Seconds
            createParticles(player.x, player.y, 20, '#ffffff');
        }
    }

    // Goal Check
    if (player.x > levelData.goalX) {
        levelComplete();
    }

    // Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    // Progress Bar
    const progress = Math.min(100, (player.x / levelData.goalX) * 100);
    document.getElementById('progress-fill').style.width = `${progress}%`;
}

/**
 * RENDERING
 */

function drawBackground() {
    const config = LEVELS[currentLevelIndex];
    
    // Sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
    grad.addColorStop(0, config.bgColors[0]);
    grad.addColorStop(0.5, config.bgColors[1]);
    grad.addColorStop(1, config.bgColors[2]);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Retro Sun
    const sunY = 150;
    ctx.fillStyle = `rgba(255, 42, 109, 0.2)`; 
    ctx.beginPath();
    ctx.arc(GAME_WIDTH / 2, sunY + (camera.x * 0.05) % 10, 100, 0, Math.PI * 2);
    ctx.fill();

    // Parallax City Layers
    // Far (Silhouettes)
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    drawCityLayer(0.1, 100, 50, 200);

    // Mid
    ctx.fillStyle = 'rgba(20, 10, 30, 0.8)';
    drawCityLayer(0.3, 150, 100, 300);

    // Near
    ctx.fillStyle = 'rgba(5, 5, 10, 0.9)';
    drawCityLayer(0.6, 200, 150, 400);
}

function drawCityLayer(speed, heightVar, widthVar, baseHeight) {
    const offset = -(camera.x * speed) % 2000;
    const yBase = GAME_HEIGHT;
    
    ctx.beginPath();
    ctx.moveTo(offset - 100, yBase);
    
    // Pseudo-random city blocks based on Math.sin to be deterministic without storage
    for(let x = -100; x < GAME_WIDTH + 200; x+= widthVar) {
        let h = Math.abs(Math.sin(x + currentLevelIndex)) * heightVar + 50;
        ctx.lineTo(x + offset, yBase - h);
        ctx.lineTo(x + widthVar + offset, yBase - h);
    }
    
    ctx.lineTo(GAME_WIDTH + offset + 200, yBase);
    ctx.fill();
}

function drawWorld() {
    const camX = Math.floor(camera.x);

    // Draw Platforms
    ctx.fillStyle = '#0f0f1a';
    ctx.strokeStyle = '#d300c5'; // Neon Purple outline
    ctx.lineWidth = 2;

    levelData.platforms.forEach(p => {
        if (p.x + p.w < camX || p.x > camX + GAME_WIDTH) return;
        
        ctx.fillRect(p.x - camX, p.y, p.w, p.h + 200); // Extend down
        
        // Grid texture on platforms
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(p.x - camX, p.y);
        ctx.lineTo(p.x + p.w - camX, p.y);
        ctx.stroke();
        
        // Vertical neon lines
        ctx.strokeStyle = 'rgba(211, 0, 197, 0.3)';
        ctx.beginPath();
        for(let gx = 0; gx < p.w; gx+=20) {
            ctx.moveTo(p.x + gx - camX, p.y);
            ctx.lineTo(p.x + gx - camX, p.y + p.h + 200);
        }
        ctx.stroke();
        ctx.restore();
    });

    // Draw Traps
    levelData.traps.forEach(t => {
        if (t.destroyed || t.x + t.w < camX || t.x > camX + GAME_WIDTH) return;

        // Glitch effect for traps
        const jitter = Math.random() * 2;
        
        if (t.type === 'small') {
            // Garbage/Crates/Barrier
            ctx.fillStyle = '#ff2a6d'; // Pink danger
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff2a6d';
            ctx.fillRect(t.x - camX + jitter, t.y, t.w, t.h);
            
            // X icon
            ctx.fillStyle = '#000';
            ctx.font = '20px Arial';
            ctx.fillText("X", t.x - camX + 5, t.y + 20);
        } else {
            // Poles/Statues
            ctx.fillStyle = '#05d9e8'; // Blue danger
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#05d9e8';
            ctx.fillRect(t.x - camX + jitter, t.y, t.w, t.h);
        }
        ctx.shadowBlur = 0;
    });

    // Draw Powerups
    levelData.powerups.forEach(p => {
        if (!p.active || p.x + p.w < camX || p.x > camX + GAME_WIDTH) return;
        
        const bob = Math.sin(frameCount * 0.1) * 5;
        ctx.fillStyle = '#ffff00';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffff00';
        
        ctx.beginPath();
        ctx.moveTo((p.x - camX) + 10, p.y + bob);
        ctx.lineTo((p.x - camX) + 20, p.y + bob + 20);
        ctx.lineTo((p.x - camX), p.y + bob + 20);
        ctx.fill();
        ctx.shadowBlur = 0;
    });

    // Draw Goal
    const gx = levelData.goalX - camX;
    if (gx < GAME_WIDTH) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(gx, 0, 100, GAME_HEIGHT);
        
        // Portal effect
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.strokeRect(gx, 100, 100, 300);
        
        ctx.font = '20px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText("GOAL", gx + 15, 250);
    }
}

function draw() {
    // Clear
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Background
    drawBackground();

    // World (Platforms, Traps)
    if (currentState !== STATE.START) {
        drawWorld();
        
        // Player
        player.draw(ctx, camera.x);
        
        // Particles
        particles.forEach(p => p.draw(ctx, camera.x));
    }

    // Chromatic Aberration Effect (Post-processing simulation)
    // We achieve this by drawing the canvas over itself slightly offset with composite operations
    // BUT for performance in this simple engine, we just draw the critical elements (Player/Traps) with offsets in their render methods or keep it clean.
    // Let's stick to the CSS scanlines for the main retro feel to save JS cycles.
}

function gameLoop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    // Cap DT to prevent physics explosion on lag
    const safeDt = Math.min(dt, 0.05);

    if (currentState === STATE.PLAYING) {
        update(safeDt);
    }
    
    draw();
    frameCount++;
    requestAnimationFrame(gameLoop);
}

/**
 * INITIALIZATION
 */

function startGame() {
    currentLevelIndex = 0;
    initLevel();
    currentState = STATE.PLAYING;
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    
    // Resume audio context if we had one (we don't, but standard practice)
}

function nextLevel() {
    currentLevelIndex++;
    if (currentLevelIndex < LEVELS.length) {
        initLevel();
        currentState = STATE.PLAYING;
        document.getElementById('level-complete-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
    }
}

function retryLevel() {
    initLevel(); // Restart current
    currentState = STATE.PLAYING;
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
}

// Event Listeners
window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
        if (currentState === STATE.PLAYING) handleInput();
        e.preventDefault();
    }
});

// Touch/Mouse
canvas.addEventListener('mousedown', handleInput);
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent scrolling
    handleInput();
}, {passive: false});

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('next-level-btn').addEventListener('click', nextLevel);
document.getElementById('retry-btn').addEventListener('click', retryLevel);

// Start Loop
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
